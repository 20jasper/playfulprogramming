---
import Document from "../../../layouts/document.astro";
import "../../../page-components/collections/framework-field-guide/fonts/fira-code.css";
import "../../../page-components/collections/framework-field-guide/fonts/plus-jakarta-sans.css";
import "../../../page-components/collections/framework-field-guide/fonts/changa-one.css";
import "../../../page-components/collections/framework-field-guide/tokens/adventure.scss";
import "../../../page-components/collections/framework-field-guide/tokens/buttons.scss";
import "../../../page-components/collections/framework-field-guide/tokens/code-block.scss";
import "../../../page-components/collections/framework-field-guide/tokens/colors.scss";
import "../../../page-components/collections/framework-field-guide/tokens/book-sections.scss";
import "../../../page-components/collections/framework-field-guide/tokens/dimensions.scss";
import "../../../page-components/collections/framework-field-guide/tokens/text-styles.scss";
import "../../../page-components/collections/framework-field-guide/tokens/themes.scss";
import "../../../page-components/collections/framework-field-guide/tokens/pricing.scss";
import SEO from "src/components/seo/seo.astro";
import Hero from "src/page-components/collections/framework-field-guide/segments/hero.astro";
import Fundamentals from "src/page-components/collections/framework-field-guide/segments/fundamentals.astro";
import Ecosystem from "src/page-components/collections/framework-field-guide/segments/ecosystem.astro";
import Internals from "src/page-components/collections/framework-field-guide/segments/internals.astro";
import AdventureContinues from "src/page-components/collections/framework-field-guide/segments/adventure-continues.astro";
import YourGuide from "src/page-components/collections/framework-field-guide/segments/your-guide.astro";
import CodeBlock from "src/page-components/collections/framework-field-guide/segments/code-block.astro";
import TheRestContainer from "src/page-components/collections/framework-field-guide/segments/the-rest-container.astro";
import Pricing from "src/page-components/collections/framework-field-guide/segments/pricing.astro";
import { unicorns } from "utils/data";
---

<Document>
	<SEO
		slot="head"
		title={"The Framework Field Guide"}
		description={"A practical and free way to teach Angular, React, and Vue all at once, so you can choose the right tool for the job and learn the underlying concepts in depth."}
		unicornsData={[unicorns.find((uni) => uni.id === "crutchcorn")]}
		publishedTime={"2022-12-01T13:45:00.284Z"}
		type={"book"}
		shareImage={"/custom-content/collections/framework-field-guide/framework_field_guide_social.png"}
	/>
	<div slot="post-body">
		<Hero />
		<Fundamentals />
		<Ecosystem />
		<Internals />
		<TheRestContainer>
			<YourGuide />
			<CodeBlock />
			<AdventureContinues />
			<Pricing />
		</TheRestContainer>
	</div>
</Document>
<script>
	// https://github.com/wuct/raf-throttle/blob/master/rafThrottle.js
	window.rafThrottle = (callback) => {
		let requestId = null;

		let lastArgs;

		const later = (context) => () => {
			requestId = null;
			callback.apply(context, lastArgs);
		};

		const throttled = function (...args) {
			lastArgs = args;
			if (requestId === null) {
				requestId = requestAnimationFrame(later(this));
			}
		};

		return throttled;
	};
</script>
<script>
	window.addEventListener("load", () => {
		const colorContainers: HTMLElement[] = Array.from(
			document.querySelectorAll("[data-change-color-to]")
		);

		const generateArrayPairChain = <T>(arr: T[]) => {
			let result = [] as Array<{ from: T; to: T }>;
			for (let i = 0; i < arr.length; i += 1) {
				if (!arr[i + 1]) return result;
				result.push({ from: arr[i], to: arr[i + 1] });
			}
			return result;
		};

		const colorContainerTransitions = generateArrayPairChain(colorContainers)
			.map((vals) => {
				const { top: topFrom, height: heightFrom } =
					vals.from.getBoundingClientRect();

				const trueTopFrom =
					topFrom +
					document.documentElement.scrollTop -
					(document.documentElement.clientTop || 0);

				const { top: topTo, height: heightTo } =
					vals.to.getBoundingClientRect();

				const trueTopTo =
					topTo +
					document.documentElement.scrollTop -
					(document.documentElement.clientTop || 0);

				const fromColor = vals.from.dataset.changeColorTo as "fund";
				const toColor = vals.to.dataset.changeColorTo as "fund";
				return {
					...vals,
					fromColor,
					toColor,
					trueTopFrom,
					trueTopTo,
					heightFrom,
					heightTo,
				};
			})
			.sort((a, b) => (a.trueTopFrom < b.trueTopFrom ? -1 : 1));

		const colorSets = [
			"050",
			"100",
			"200",
			"300",
			"400",
			"500",
			"600",
			"700",
			"800",
			"900",
		];

		const interTokens = colorSets.map((colorNum) => `--inter-${colorNum}-base`);
		const ecosTokens = colorSets.map((colorNum) => `--ecos-${colorNum}-base`);
		const fundTokens = colorSets.map((colorNum) => `--fund-${colorNum}-base`);
		const slateTokens = colorSets.map((colorNum) => `--slate-${colorNum}-base`);

		const computedStyle = window.getComputedStyle(document.documentElement);
		const initialInterTokenValues = interTokens.map((token) =>
			computedStyle.getPropertyValue(token)
		);
		const initialEcosTokenValues = ecosTokens.map((token) =>
			computedStyle.getPropertyValue(token)
		);
		const initialFundTokenValues = fundTokens.map((token) =>
			computedStyle.getPropertyValue(token)
		);
		const initialSlateTokenValues = slateTokens.map((token) =>
			computedStyle.getPropertyValue(token)
		);

		let windowsInnerHeight = window.innerHeight;

		window.addEventListener("resize", () => {
			windowsInnerHeight = window.innerHeight;
		});

		function changeColorSetTo(
			colorSetToChangeTo: "fund" | "ecos" | "slate" | "inter"
		) {
			switch (colorSetToChangeTo) {
				case "fund": {
					fundTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialFundTokenValues[index]
						);
					});
					interTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialFundTokenValues[index]
						);
					});
					ecosTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialFundTokenValues[index]
						);
					});
					slateTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialFundTokenValues[index]
						);
					});
					break;
				}
				case "ecos": {
					ecosTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialEcosTokenValues[index]
						);
					});
					interTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialEcosTokenValues[index]
						);
					});
					fundTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialEcosTokenValues[index]
						);
					});
					slateTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialEcosTokenValues[index]
						);
					});
					break;
				}
				case "inter": {
					interTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialInterTokenValues[index]
						);
					});
					ecosTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialInterTokenValues[index]
						);
					});
					fundTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialInterTokenValues[index]
						);
					});
					slateTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialInterTokenValues[index]
						);
					});
					break;
				}
				default:
				case "slate": {
					slateTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialSlateTokenValues[index]
						);
					});
					ecosTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialSlateTokenValues[index]
						);
					});
					fundTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialSlateTokenValues[index]
						);
					});
					interTokens.forEach((tokenName, index) => {
						document.documentElement.style.setProperty(
							tokenName,
							initialSlateTokenValues[index]
						);
					});
					break;
				}
			}
		}

		function checkColorToSetTo({
			scrollTop,
			transitionData,
			i,
		}: {
			scrollTop: number;
			transitionData: typeof colorContainerTransitions[0];
			i: number;
		}) {
			const halfScreenHeight = windowsInnerHeight / 2;

			if (transitionData.trueTopTo < scrollTop + halfScreenHeight) {
				if (i === colorContainerTransitions.length - 1) {
					changeColorSetTo(transitionData.toColor);
					return;
				}

				changeColorSetTo(transitionData.toColor);
			} else if (transitionData.trueTopFrom < scrollTop - halfScreenHeight) {
				changeColorSetTo(transitionData.fromColor);
			} else if (i === 0 && scrollTop < transitionData.trueTopFrom) {
				changeColorSetTo(transitionData.fromColor);
			}
		}

		let timeout;
		function checkPassiveScrollPositionAndColor() {
			clearTimeout(timeout);
			timeout = setTimeout(() => {
				const scrollTop = document.documentElement.scrollTop;

				let dataIndex = colorContainerTransitions.findIndex(
					(transitionData) => {
						return transitionData.trueTopFrom >= scrollTop;
					}
				);
				if (dataIndex === -1) {
					dataIndex = colorContainerTransitions.length - 1;
				}
				checkColorToSetTo({
					transitionData: colorContainerTransitions[dataIndex],
					i: dataIndex,
					scrollTop,
				});
			}, 10);
		}

		const throttledPassiveScrollColorChange = window.rafThrottle(
			checkPassiveScrollPositionAndColor
		);
		window.addEventListener("scroll", throttledPassiveScrollColorChange);
		window.addEventListener("touchmove", throttledPassiveScrollColorChange);

		throttledPassiveScrollColorChange();

		const listenForEvents = (i: number) => {
			const checkPositionAndChangeColor = () => {
				const transitionData = colorContainerTransitions[i];
				const scrollTop = document.documentElement.scrollTop;

				if (
					scrollTop >
					transitionData.trueTopFrom + transitionData.heightFrom
				) {
					return;
				}

				checkColorToSetTo({
					scrollTop,
					transitionData,
					i,
				});
			};
			const throttledScrollColorChange = window.rafThrottle(
				checkPositionAndChangeColor
			);
			window.addEventListener("scroll", throttledScrollColorChange);
			window.addEventListener("touchmove", throttledScrollColorChange);
		};

		for (let i = 0; i < colorContainerTransitions.length; i++) {
			listenForEvents(i);
		}
	});
</script>

<script>
	import { enableTabs } from "../../../utils/markdown/scripts/tabs";
	enableTabs();
</script>
<script>
	// Thanks https://easings.net/
	function easeOutExpo(x: number): number {
		return x === 1 ? 1 : 1 - 2 ** (-10 * x);
	}

	window.addEventListener("load", () => {
		const els = Array.from(
			document.querySelectorAll("[data-move-on-scroll-by]")
		) as HTMLElement[];
		const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");

		const getElTops = () =>
			els.map((el) => {
				el.style.transform = "";
				var { top: topRect, height } = el.getBoundingClientRect();

				let top =
					topRect +
					document.documentElement.scrollTop -
					(document.documentElement.clientTop || 0);

				// Keep this value around for the same 'innerHeight' calculation for later
				const trueTop = top;

				// If the item is below the upper fold, let's go ahead and start listening at 50% of the screen height, when the element is visible
				if (top >= window.innerHeight) {
					// Start animating once the element is midway down the screen
					top = top - (window.innerHeight - height) / 2;
				}

				const moveOnScrollBy = Number(el.dataset.moveOnScrollBy);

				const parentHeight = el.parentElement.clientHeight;

				return { top, trueTop, moveOnScrollBy, parentHeight };
			});

		let initialElTops = getElTops();

		window.addEventListener("resize", () => {
			initialElTops = getElTops();
			moveItems();
		});

		function moveItems() {
			const scrollTop = document.documentElement.scrollTop;
			for (let i = 0; i < els.length; i++) {
				const el = els[i];
				const { top, trueTop, moveOnScrollBy, parentHeight } = initialElTops[i];

				// If the element is above the fold, start running immediately
				const disableTop = trueTop < window.innerHeight;

				const topCalc = disableTop ? 0 : top;

				let px = (scrollTop - topCalc) * moveOnScrollBy;

				// Only allow the animation to go up by 10% of the height of the element at most
				const maximumNegativeAllowed = 0 - parentHeight * 0.4 * moveOnScrollBy;

				if (top >= window.innerHeight) {
					if (px > maximumNegativeAllowed && px < -1) {
						const positivePx = 0 - px;
						const positiveMaxAllowed = 0 - maximumNegativeAllowed;

						const multiplier = easeOutExpo(positivePx / positiveMaxAllowed);
						px = px * multiplier;
					}

					if (px < maximumNegativeAllowed) {
						px = maximumNegativeAllowed;
					}
				}

				el.style.transform = `translateY(${px}px)`;
			}
		}

		const throttledMoveItems = window.rafThrottle(moveItems);
		if (!mediaQuery.matches) {
			window.addEventListener("scroll", throttledMoveItems);
			window.addEventListener("touchmove", throttledMoveItems);
		}
		mediaQuery.addEventListener("change", () => {
			if (mediaQuery.matches) {
				els.forEach((el: HTMLElement) => (el.style.transform = ""));
				window.removeEventListener("scroll", throttledMoveItems);
				window.removeEventListener("touchmove", throttledMoveItems);
			} else {
				window.addEventListener("scroll", throttledMoveItems);
				window.addEventListener("touchmove", throttledMoveItems);
			}
		});
	});
</script>
<style is:global>
	*:focus-visible {
		outline: none;
	}

	*:focus-visible::after {
		content: " ";
		position: absolute;
		box-sizing: content-box;
		height: 100%;
		width: 100%;
		padding: var(--focus-border_gap);
		top: 50%;
		left: 50%;
		transform: translateX(-50%) translateY(-50%);
		border-width: inherit;
		border-style: solid;
		border-color: transparent;
		border-radius: inherit;
		outline: var(--focus-border_width) solid var(--outline_focused);
		z-index: 9;
	}

	[data-move-on-scroll-by] {
		will-change: transform;
	}

	.repeat-background-svg-container,
	repeat-background-svg-container > svg {
		height: 100%;
		aspect-ratio: var(--svgAspectRatio);
	}
</style>
