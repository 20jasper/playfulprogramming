
// arrValue<T>: Array<{id: string, val: T}>
// Use useMemo and return
//const arrValue = getUniqueIds(arr);

// active is the last selected
// selected is the array of currently selected
// manual way to toggle one
// if shift is being pressed and selectIndex is fired, act as `startSelect` then, etc

/*
interface SelectRefWrapperType<T> {
val: T;
selected: boolean;
id: string; // generated by a getUniqueIDs inside
}

interface useSelectRefReturn<T> {
selectIndex: (i, e?: MouseEvent) => void; // event is to detect select
active: T;
selected: T;
ref: ReturnType<typeof useImperativeHandle>;
}
**/

//const {ref, active, selected, selectIndex} = useSelectRef(arrValue);

// These are created by useImperativeHandle
/**
 ref.current.activeNext()
 ref.current.activeLast()
 ref.current.startSelect() // not quite how it done internally, do check on keyevent if shift modifier
 ref.current.endSelect()
 ref.current.select()
 ref.current.selectAll()
 **/
// These should not be needed, `addEventListener` can be handled properly with `useEffect` and a return statement with the ref being used as the secondary

//<div ref={ref} aria-selected={active.id}/>
