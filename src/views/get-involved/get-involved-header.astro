---
import { getUnicornsByLang } from "../../utils/api";
import { getInitialItems } from "./get-involved-header";
import style from "./get-involved-header.module.scss";
import Hr from "./hr.astro";

const NUMBER_OF_INNER_ITEMS = 22;
const NUMBER_OF_OUTER_ITEMS = 28;
const INNER_OFFSET = 150;
const OUTER_OFFSET = 300;

const initialInnerItems = getInitialItems(NUMBER_OF_INNER_ITEMS, INNER_OFFSET);
const initialOuterItems = getInitialItems(NUMBER_OF_OUTER_ITEMS, OUTER_OFFSET);

const unicorns = getUnicornsByLang("en");
const reverseUnicorns = unicorns.slice().reverse();

const getSafeIndex = <T,>(array: T[], index: number) => {
	return array[index % array.length];
};
---

<div class={style.headerContainer}>
	<div class={style.getInvolvedContainer}>
		<div class={style.getInvolvedContents}>
			<h1 class={style.getInvolvedHeader}>Get involved</h1>
			<div class={style.break}>
				<Hr />
			</div>
			<div class={style.paragraphContainer}>
				<p class={`text-style-body-large ${style.paragraph}`}>
					Playful Programming embraces the best part of Open Source: Weâ€™re ran
					by real people wanting to make an impact in the world and help others
					learn and join us along the journey.
				</p>
			</div>
		</div>
		<div class={style.innerInvolvedContainer} id="inner-circle-container">
			{
				initialInnerItems.map((item, index) => {
					const unicorn = getSafeIndex(unicorns, index);
					return (
						<div
							data-is-circle-inner-item
							id={`circle-item-inner-${index}`}
							class={style.circleItem}
							style={{
								left: item.x,
								top: item.y,
								backgroundImage: `url(${encodeURI(unicorn.profileImgMeta.relativeServerPath)})`,
								transform: `scale(${item.scale}) translate(-50%, -50%)`,
							}}
						>
							{unicorn.roles[0] && (
								<img
									class={style.stickerRole}
									src={`/stickers/role_${unicorn.roles[0]}.svg`}
									alt=""
								/>
							)}
						</div>
					);
				})
			}
		</div>
		<div class={style.outerInvolvedContainer} id="outer-circle-container">
			{
				initialOuterItems.map((item, index) => {
					const unicorn = getSafeIndex(reverseUnicorns, index);
					return (
						<div
							data-is-circle-outer-item
							id={`circle-item-outer-${index}`}
							class={style.circleItem}
							style={{
								left: item.x,
								top: item.y,
								backgroundImage: `url(${encodeURI(unicorn.profileImgMeta.relativeServerPath)})`,
								transform: `scale(${item.scale}) translate(-50%, -50%)`,
							}}
						>
							{unicorn.roles[0] && (
								<img
									class={style.stickerRole}
									src={`/stickers/role_${unicorn.roles[0]}.svg`}
									alt=""
								/>
							)}
						</div>
					);
				})
			}
		</div>
	</div>
</div>

<script>
	// In a 30fps requestAnimationFrame loop, take each item and change the X, Y, and scale to rotate the items in the circle clockwise
	import { getInitialItems, calculatePosition } from "./get-involved-header";

	const DECELERATION_RATE = 0.99;
	const MIN_SPEED_THRESHOLD = 0.0001;
	const INNER_CIRCLE_ROTATION_SPEED = 0.001;
	const OUTER_CIRCLE_ROTATION_SPEED = 0.0005;
	const SPEED_CALCULATION_FACTOR = 0.01;
	const OUTER_SPEED_MULTIPLIER = 0.5;
	const INNER_OFFSET = 150;
	const OUTER_OFFSET = 300;

	const innerCircle = document.querySelectorAll("[data-is-circle-inner-item]");
	const outerCircle = document.querySelectorAll("[data-is-circle-outer-item]");
	const innerContainer = document.querySelector("#inner-circle-container")!;
	const outerContainer = document.querySelector("#outer-circle-container")!;

	let innerAngle = 0;
	let outerAngle = 0;
	let shouldUpdate = true;
	let prevX = 0;
	let speed = 0;
	let decelerating = false;

	function calculateSpeed(e: MouseEvent | TouchEvent) {
		const isMouseEvent = (e: any): e is MouseEvent => {
			return "clientX" in e;
		};
		const currentX = isMouseEvent(e) ? e.clientX : e.touches[0].clientX;
		if (prevX === 0) prevX = currentX;
		const diff = currentX - prevX;
		speed = diff * SPEED_CALCULATION_FACTOR;
		prevX = currentX;
	}

	function onMouseMove(e: MouseEvent) {
		calculateSpeed(e);
		innerAngle -= speed;
		outerAngle -= speed * OUTER_SPEED_MULTIPLIER;
		redraw();
	}

	function onTouchMove(e: TouchEvent) {
		calculateSpeed(e);
		innerAngle -= speed;
		outerAngle -= speed * OUTER_SPEED_MULTIPLIER;
		redraw();
	}

	function startDeceleration() {
		if (speed !== 0) {
			decelerating = true;
			requestAnimationFrame(decelerate);
		}
	}

	function decelerate() {
		if (!decelerating) return;
		innerAngle -= speed;
		outerAngle -= speed * OUTER_SPEED_MULTIPLIER;
		redraw();
		speed *= DECELERATION_RATE;
		if (Math.abs(speed) < MIN_SPEED_THRESHOLD) {
			decelerating = false;
			speed = 0;
		} else {
			requestAnimationFrame(decelerate);
		}
	}

	function onMouseUp() {
		if (speed !== 0) {
			decelerating = true;
			requestAnimationFrame(decelerate);
		}
	}

	function onTouchEnd() {
		if (speed !== 0) {
			decelerating = true;
			requestAnimationFrame(decelerate);
		}
	}

	function redraw() {
		innerCircle.forEach((element: HTMLElement, index) => {
			const { x, y, scale } = calculatePosition(
				innerCircle.length,
				index + innerAngle,
				INNER_OFFSET,
			);
			element.style.left = `${x}%`;
			element.style.top = `${y}%`;
			element.style.transform = `scale(${scale}) translate(-50%, -50%)`;
		});
		outerCircle.forEach((element: HTMLElement, index) => {
			const { x, y, scale } = calculatePosition(
				outerCircle.length,
				index + outerAngle,
				OUTER_OFFSET,
			);
			element.style.left = `${x}%`;
			element.style.top = `${y}%`;
			element.style.transform = `scale(${scale}) translate(-50%, -50%)`;
		});
	}

	function update() {
		if (!shouldUpdate) return;
		innerAngle += INNER_CIRCLE_ROTATION_SPEED;
		outerAngle += OUTER_CIRCLE_ROTATION_SPEED;
		redraw();
		requestAnimationFrame(update);
	}

	function setupEventListeners() {
		function handleDragStart(e: MouseEvent | TouchEvent) {
			shouldUpdate = false;
			if (e.type === "mousedown") {
				document.addEventListener("mousemove", onMouseMove);
			} else if (e.type === "touchstart") {
				document.addEventListener("touchmove", onTouchMove);
			}
		}

		function handleDragEnd() {
			document.removeEventListener("mousemove", onMouseMove);
			document.removeEventListener("touchmove", onTouchMove);
			prevX = 0;
			if (!shouldUpdate) {
				shouldUpdate = true;
				update();
			}
		}

		function setupContainerListeners(container: Element) {
			container.addEventListener("touchstart", handleDragStart);
			container.addEventListener("mousedown", handleDragStart);
		}

		document.addEventListener("mouseup", startDeceleration);
		document.addEventListener("touchend", startDeceleration);
		document.addEventListener("mouseup", handleDragEnd);
		document.addEventListener("touchend", handleDragEnd);

		return {
			setupContainerListeners,
		};
	}

	// Setup event listeners
	const { setupContainerListeners } = setupEventListeners();
	setupContainerListeners(innerContainer);
	setupContainerListeners(outerContainer);

	// Start the event loop
	update();
</script>
